<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="你只管努力，剩下的交给天意">
<meta property="og:type" content="website">
<meta property="og:title" content="sbing的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sbing的博客">
<meta property="og:description" content="你只管努力，剩下的交给天意">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sbing的博客">
<meta name="twitter:description" content="你只管努力，剩下的交给天意">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>sbing的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sbing的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/redis之列表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/20/redis之列表/" class="post-title-link" itemprop="url">redis之列表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-20 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-20T17:01:21+08:00">2019-02-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:51:20" itemprop="dateModified" datetime="2019-03-02T15:51:20+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>列表</strong>（ <code>list</code>）类型是用来存储多个 <strong>有序</strong> 的 <strong>字符串</strong>。在 <code>Redis</code> 中，可以对列表的 <strong>两端</strong> 进行 <strong>插入</strong>（ <code>push</code>）和 <strong>弹出</strong>（ <code>pop</code>）操作，还可以获取 <strong>指定范围</strong> 的 <strong>元素列表</strong>、获取 <strong>指定索引下标</strong> 的 <strong>元素</strong> 等。</p>
<p><strong>列表</strong> 是一种比较 <strong>灵活</strong> 的 <strong>数据结构</strong>，它可以充当 <strong>栈</strong> 和 <strong>队列</strong> 的角色，在实际开发上有很多应用场景。</p>
<h1 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h1><p>列表类型的 <strong>内部编码</strong> 有两种：</p>
<h2 id="ziplist（压缩列表）"><a href="#ziplist（压缩列表）" class="headerlink" title="ziplist（压缩列表）"></a>ziplist（压缩列表）</h2><p>当列表的元素个数 <strong>小于</strong> <code>list-max-ziplist-entries</code> 配置（默认 <code>512</code> 个），同时列表中 <strong>每个元素</strong> 的值都 <strong>小于</strong> <code>list-max-ziplist-value</code> 配置时（默认 <code>64</code> 字节）， <code>Redis</code>会选用 <code>ziplist</code> 来作为 <strong>列表</strong> 的 <strong>内部实现</strong> 来减少内存的使用。</p>
<h2 id="linkedlist（链表）"><a href="#linkedlist（链表）" class="headerlink" title="linkedlist（链表）"></a>linkedlist（链表）</h2><p>当 <strong>列表类型</strong> 无法满足 <code>ziplist</code> 的条件时， <code>Redis</code> 会使用 <code>linkedlist</code> 作为 <strong>列表</strong> 的 <strong>内部实现</strong>。</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><ul>
<li><p>当元素 <strong>个数较少</strong> 且 <strong>没有大元素</strong> 时，<strong>内部编码</strong> 为 <code>ziplist</code>：</p>
</li>
<li><p>当元素个数超过 <code>512</code> 个，<strong>内部编码</strong> 变为 <code>linkedlist</code>：</p>
</li>
<li><p>当某个元素超过 <code>64</code> <strong>字节</strong>，<strong>内部编码</strong> 也会变为 <code>linkedlist</code>：</p>
</li>
</ul>
<p><code>Redis3.2</code> 版本提供了 <code>quicklist</code> <strong>内部编码</strong>，简单地说它是以一个 <code>ziplist</code> 为 <strong>节点</strong> 的 <code>linkedlist</code>，它结合了 <code>ziplist</code> 和 <code>linkedlist</code> 两者的优势，为 <strong>列表类型</strong> 提供了一种更为优秀的 <strong>内部编码</strong> 实现。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>通过 <code>Redis</code> 的 <code>lpush+brpop</code> <strong>命令组合</strong>，即可实现 <strong>阻塞队列</strong>。</p>
<p><strong>生产者客户端</strong> 使用 <code>lrpush</code> 从列表 <strong>左侧插入元素</strong>，<strong>多个消费者客户端</strong> 使用 <code>brpop</code> 命令 <strong>阻塞式</strong> 的 <strong>“抢”</strong> 列表 <strong>尾部</strong> 的元素，<strong>多个客户端</strong> 保证了消费的 <strong>负载均衡</strong> 和 <strong>高可用性</strong>。</p>
<h2 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h2><p>每个 <strong>用户</strong> 有属于自己的 <strong>文章列表</strong>，现需要 <strong>分页</strong> 展示文章列表。此时可以考虑使用 <strong>列表</strong>，因为列表不但是 <strong>有序的</strong>，同时支持 <strong>按照索引范围</strong> 获取元素。</p>
<table>
<thead>
<tr>
<th>命令组合</th>
<th>对应数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpush + lpop</td>
<td>Stack（栈）</td>
</tr>
<tr>
<td>lpush + rpop</td>
<td>Queue（队列）</td>
</tr>
<tr>
<td>lpush + ltrim</td>
<td>Capped Collection（有限集合）</td>
</tr>
<tr>
<td>lpush + brpop</td>
<td>Message Queue（消息队列）</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/redis之哈希/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/18/redis之哈希/" class="post-title-link" itemprop="url">redis之哈希</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-18 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-18T17:01:21+08:00">2019-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:46:55" itemprop="dateModified" datetime="2019-03-02T15:46:55+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里先不展示常用命令。</p>
<p>在 <code>Redis</code> 中，<strong>哈希类型</strong> 是指键值本身又是一个 <strong>键值对结构</strong>。</p>
<p>在使用 <code>hgetall</code> 时，如果 <strong>哈希元素</strong> 个数比较多，会存在 <strong>阻塞</strong> <code>Redis</code> 的可能。如果开发人员只需要获取 <strong>部分</strong> <code>field</code>，可以使用 <code>hmget</code>，如果一定要获取 <strong>全部</strong> <code>field-value</code>，可以使用 <code>hscan</code> 命令，该命令会 <strong>渐进式遍历</strong> 哈希类型。</p>
<h1 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h1><p><strong>哈希类型</strong> 的 <strong>内部编码</strong> 有两种：</p>
<h2 id="ziplist（压缩列表）"><a href="#ziplist（压缩列表）" class="headerlink" title="ziplist（压缩列表）"></a>ziplist（压缩列表）</h2><p>当 <strong>哈希类型</strong> 元素个数 <strong>小于</strong> <code>hash-max-ziplist-entries</code> 配置（默认 <code>512</code>个）、同时 <strong>所有值</strong> 都 <strong>小于</strong> <code>hash-max-ziplist-value</code> 配置（默认 <code>64</code> 字节）时， <code>Redis</code> 会使用 <code>ziplist</code> 作为 <strong>哈希</strong> 的 <strong>内部实现</strong>， <code>ziplist</code> 使用更加 <strong>紧凑的结构</strong> 实现多个元素的 <strong>连续存储</strong>，所以在 <strong>节省内存</strong> 方面比 <code>hashtable</code> 更加优秀。</p>
<h2 id="hashtable（哈希表）"><a href="#hashtable（哈希表）" class="headerlink" title="hashtable（哈希表）"></a>hashtable（哈希表）</h2><p>当 <strong>哈希类型</strong> 无法满足 <code>ziplist</code> 的条件时， <code>Redis</code> 会使用 <code>hashtable</code> 作为 <strong>哈希</strong>的 <strong>内部实现</strong>，因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降，而 <code>hashtable</code> 的读写 <strong>时间复杂度</strong> 为 <code>O（1）</code>。</p>
<p>下面的示例演示了 <strong>哈希类型</strong> 的 <strong>内部编码</strong>，以及相应的变化。</p>
<p>当 <code>field</code> 个数 <strong>比较少</strong>，且没有大的 <code>value</code> 时，<strong>内部编码</strong> 为 <code>ziplist</code></p>
<ul>
<li>当有 <code>value</code> <strong>大于</strong> <code>64</code> 字节时，<strong>内部编码</strong> 会由 <code>ziplist</code> 变为 <code>hashtable</code>：</li>
<li>当 <code>field</code> 个数 <strong>超过</strong> <code>512</code>，<strong>内部编码</strong> 也会由 <code>ziplist</code> 变为 <code>hashtable</code>：</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/redis之字符串/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/17/redis之字符串/" class="post-title-link" itemprop="url">redis之字符串</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-17 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-17T17:01:21+08:00">2019-02-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:42:41" itemprop="dateModified" datetime="2019-03-02T15:42:41+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>字符串类型</strong> 是 <code>Redis</code> 最基础的数据结构。<strong>字符串类型</strong> 的值实际可以是 <strong>字符串</strong>（<strong>简单</strong> 和 <strong>复杂</strong> 的字符串，例如 <code>JSON</code>、 <code>XML</code>）、<strong>数字</strong>（整数、浮点数），甚至是 <strong>二进制</strong>（图片、音频、视频），但是值最大不能超过 <code>512MB</code>。</p>
<p><code>incr</code> 命令用于对值做 <strong>自增操作</strong>，返回结果分为三种情况：</p>
<ul>
<li>值不是 <strong>整数</strong>，返回 <strong>错误</strong>。</li>
<li>值是 <strong>整数</strong>，返回 <strong>自增</strong> 后的结果。</li>
<li>键不存在，按照值为 <code>0</code> <strong>自增</strong>，返回结果为 <code>1</code>。</li>
</ul>
<p>除了 <code>incr</code> 命令， <code>Redis</code> 还提供了 <code>decr</code>（<strong>自减</strong>）、 <code>incrby</code>（<strong>自增指定数字</strong>）、 <code>decrby</code>（<strong>自减指定数字</strong>）、 <code>incrbyfloat</code>（<strong>自增浮点数</strong>）等命令操作：</p>
<h1 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h1><p><strong>字符串</strong> 类型的 <strong>内部编码</strong> 有 <code>3</code> 种：</p>
<ul>
<li><strong>int</strong>： <code>8</code> 个字节的 <strong>长整型</strong>。</li>
<li><strong>embstr</strong>：<strong>小于等于</strong> <code>39</code> 个字节的字符串。</li>
<li><strong>raw</strong>：<strong>大于</strong> <code>39</code> 个字节的字符串。</li>
</ul>
<p><code>Redis</code> 会根据当前值的 <strong>类型</strong> 和 <strong>长度</strong> 决定使用哪种 <strong>内部编码实现</strong>。</p>
<h1 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h1><h2 id="缓存功能"><a href="#缓存功能" class="headerlink" title="缓存功能"></a>缓存功能</h2><p>下面是一种比较典型的 <strong>缓存</strong> 使用场景，其中 <code>Redis</code> 作为 <strong>缓存层</strong>， <code>MySQL</code> 作为 <strong>存储层</strong>，绝大部分请求的数据都是从 <code>Redis</code> 中获取。由于 <code>Redis</code> 具有支撑 <strong>高并发</strong> 的特性，所以缓存通常能起到 <strong>加速读写</strong> 和 <strong>降低后端压力</strong> 的作用。</p>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>许多应用都会使用 <code>Redis</code> 作为 <strong>计数</strong> 的基础工具，它可以实现 <strong>快速计数</strong>、<strong>查询缓存</strong> 的功能，同时数据可以 <strong>异步落地</strong> 到其他 <strong>数据源</strong>。一般来说，视频播放数系统，就是使用 <code>Redis</code>作为 <strong>视频播放数计数</strong> 的基础组件，用户每播放一次视频，相应的视频播放数就会自增 <code>1</code>。</p>
<h2 id="共享Session"><a href="#共享Session" class="headerlink" title="共享Session"></a>共享Session</h2><p>一个 <strong>分布式</strong> <code>Web</code> 服务将用户的 <code>Session</code> 信息（例如 <strong>用户登录信息</strong>）保存在 <strong>各自</strong> 的服务器中。这样会造成一个问题，出于 <strong>负载均衡</strong> 的考虑，<strong>分布式服务</strong> 会将用户的访问 <strong>均衡</strong> 到不同服务器上，用户 <strong>刷新一次访问</strong> 可能会发现需要 <strong>重新登录</strong>，这个问题是用户无法容忍的。</p>
<h2 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h2><p>很多应用出于安全的考虑，会在每次进行登录时，让用户输入 <strong>手机验证码</strong>，从而确定是否是用户本人。但是为了 <strong>短信接口</strong> 不被 <strong>频繁访问</strong>，会 <strong>限制</strong> 用户每分钟获取 <strong>验证码</strong> 的频率。</p>
<p>上述就是利用 <code>Redis</code> 实现了 <strong>限速功能</strong>，例如 <strong>一些网站</strong> 限制一个 <code>IP</code> 地址不能在 <strong>一秒钟之内</strong> 访问超过 <code>n</code> 次也可以采用 <strong>类似</strong> 的思路。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/redis数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/redis数据结构/" class="post-title-link" itemprop="url">redis数据结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-14 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-14T17:01:21+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:38:01" itemprop="dateModified" datetime="2019-03-02T15:38:01+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h1><p><code>Redis</code> 有 <code>5</code> 种 <strong>数据结构</strong>，它们是 <strong>键值对</strong> 中的 <strong>值</strong>，对于 <strong>键</strong> 来说有一些通用的命令。</p>
<h2 id="查看所有键"><a href="#查看所有键" class="headerlink" title="查看所有键"></a>查看所有键</h2><blockquote>
<p>keys *</p>
</blockquote>
<h2 id="键总数"><a href="#键总数" class="headerlink" title="键总数"></a>键总数</h2><blockquote>
<p>dbsize</p>
</blockquote>
<p><code>dbsize</code> 命令在 <strong>计算键总数</strong> 时 <strong>不会遍历</strong> 所有键，而是直接获取 <code>Redis</code> <strong>内置的键总数变量</strong>，所以 <code>dbsize</code> 命令的 <strong>时间复杂度</strong> 是 <code>O（1）</code>。而 <code>keys</code> 命令会 <strong>遍历</strong>所有键，所以它的 <strong>时间复杂度</strong> 是 <code>O（n）</code>，当 <code>Redis</code> 保存了 <strong>大量键</strong> 时，线上环境 <strong>禁止</strong> 使用。</p>
<h2 id="检查键是否存在"><a href="#检查键是否存在" class="headerlink" title="检查键是否存在"></a>检查键是否存在</h2><blockquote>
<p>exists key</p>
</blockquote>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><blockquote>
<p>del key</p>
</blockquote>
<p><code>del</code> 是一个 <strong>通用命令</strong>，无论值是什么 <strong>数据结构</strong> 类型， <code>del</code> 命令都可以将其 <strong>删除</strong>。</p>
<h2 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a>键过期</h2><blockquote>
<p>expire key seconds</p>
</blockquote>
<p><code>Redis</code> 支持对 <strong>键</strong> 添加 <strong>过期时间</strong>，当超过过期时间后，会 <strong>自动删除键</strong></p>
<p><code>ttl</code> 命令会返回键的 <strong>剩余过期时间</strong>，它有 <code>3</code> 种返回值：</p>
<ul>
<li>大于等于 <code>0</code> 的整数：表示键 <strong>剩余</strong> 的 <strong>过期时间</strong>。</li>
<li>返回 <code>-1</code>：<strong>键</strong> 没设置 <strong>过期时间</strong>。</li>
<li>返回 <code>-2</code>：<strong>键</strong> 不存在。</li>
</ul>
<p>可以通过 <code>ttl</code> 命令观察 <strong>键</strong> <code>hello</code> 的 <strong>剩余过期时间</strong></p>
<h2 id="键的数据结构类型"><a href="#键的数据结构类型" class="headerlink" title="键的数据结构类型"></a>键的数据结构类型</h2><blockquote>
<p>type key</p>
</blockquote>
<h1 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h1><p><code>type</code> 命令实际返回的就是当前 <strong>键</strong> 的 <strong>数据结构类型</strong>，它们分别是： <code>string</code>（<strong>字符串</strong>）、 <code>hash</code>（<strong>哈希</strong>）、 <code>list</code>（<strong>列表</strong>）、 <code>set</code>（<strong>集合</strong>）、 <code>zset</code>（<strong>有序集合</strong>），但这些只是 <code>Redis</code> 对外的 <strong>数据结构</strong>。</p>
<p><img src="/img/redis3.jpg" alt=""></p>
<p>对于每种 <strong>数据结构</strong>，实际上都有自己底层的 <strong>内部编码</strong> 实现，而且是 <strong>多种实现</strong>。这样 <code>Redis</code> 会在合适的 <strong>场景</strong> 选择合适的 <strong>内部编码</strong>，如图所示：</p>
<p><img src="/img/redis4.jpg" alt=""></p>
<p>可以看到，每种 <strong>数据结构</strong> 都有 <strong>两种以上</strong> 的 <strong>内部编码实现</strong>。例如 <code>list</code> <strong>数据结构</strong>包含了 <code>linkedlist</code> 和 <code>ziplist</code> 两种 <strong>内部编码</strong>。同时有些 <strong>内部编码</strong>，例如 <code>ziplist</code>，可以作为 <strong>多种外部数据结构</strong> 的内部实现</p>
<h1 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h1><p><code>Redis</code> 使用了 <strong>单线程架构</strong> 和 <code>I/O</code> <strong>多路复用模型</strong> 来实现 <strong>高性能</strong> 的 <strong>内存数据库服务</strong>。那为什么 <strong>单线程</strong> 还能这么快，下面分析原因：</p>
<h2 id="纯内存访问"><a href="#纯内存访问" class="headerlink" title="纯内存访问"></a>纯内存访问</h2><p><code>Redis</code> 将所有数据放在 <strong>内存</strong> 中，内存的 <strong>响应时长</strong> 大约为 <code>100</code> <strong>纳秒</strong>，这是 <code>Redis</code>达到 <strong>每秒万级别</strong> 访问的重要基础。</p>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p><code>Redis</code> 使用 <code>epoll</code> 作为 <code>I/O</code> <strong>多路复用技术</strong> 的实现，再加上 <code>Redis</code> 自身的 <strong>事件处理模型</strong> 将 <code>epoll</code> 中的 <strong>连接</strong>、<strong>读写</strong>、<strong>关闭</strong> 都转换为 <strong>事件</strong>，从而不用不在 <strong>网络</strong> <code>I/O</code> 上浪费过多的时间，如图所示：</p>
<p>采用 <strong>单线程</strong> 就能达到如此 <strong>高的性能</strong>，那么不失为一种不错的选择，因为 <strong>单线程</strong>能带来几个好处：</p>
<ul>
<li><strong>单线程</strong> 可以简化 <strong>数据结构和算法</strong> 的实现，开发人员不需要了解复杂的 <strong>并发数据结构</strong>。</li>
<li><strong>单线程</strong> 避免了 <strong>线程切换</strong> 和 <strong>竞态</strong> 产生的消耗，对于服务端开发来说，<strong>锁和线程切换</strong> 通常是性能杀手。</li>
</ul>
<p><strong>单线程</strong> 的问题：对于 <strong>每个命令</strong> 的 <strong>执行时间</strong> 是有要求的。如果某个命令 <strong>执行过长</strong>，会造成其他命令的 <strong>阻塞</strong>，对于 <code>Redis</code> 这种 <strong>高性能</strong> 的服务来说是致命的，所以 <code>Redis</code>是面向 <strong>快速执行</strong> 场景的数据库。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/Redis集群模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/Redis集群模式/" class="post-title-link" itemprop="url">redis集群模式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-12 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-12T17:01:21+08:00">2019-02-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:27:38" itemprop="dateModified" datetime="2019-03-02T15:27:38+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 <code>Redis 3.0</code> 之前，使用 <strong>哨兵</strong>（ <code>sentinel</code>）机制来监控各个节点之间的状态。 <code>Redis Cluster</code> 是 <code>Redis</code> 的 <strong>分布式解决方案</strong>，在 <code>3.0</code> 版本正式推出，有效地解决了 <code>Redis</code> 在 <strong>分布式</strong> 方面的需求。当遇到 <strong>单机内存</strong>、<strong>并发</strong>、<strong>流量</strong> 等瓶颈时，可以采用 <code>Cluster</code> 架构方案达到 <strong>负载均衡</strong> 的目的。</p>
<h1 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h1><p><code>RedisCluster</code> 集群模式通常具有 <strong>高可用</strong>、<strong>可扩展性</strong>、<strong>分布式</strong>、<strong>容错</strong> 等特性。 <code>Redis</code> 分布式方案一般有两种：</p>
<h2 id="客户端分区方案"><a href="#客户端分区方案" class="headerlink" title="客户端分区方案"></a>客户端分区方案</h2><p><strong>客户端</strong> 就已经决定数据会被 <strong>存储</strong> 到哪个 <code>redis</code> 节点或者从哪个 <code>redis</code> 节点 <strong>读取数据</strong>。其主要思想是采用 <strong>哈希算法（hash slot算法）</strong> 将 <code>Redis</code> 数据的 <code>key</code> 进行散列，通过 <code>hash</code>函数，特定的 <code>key</code>会 <strong>映射</strong> 到特定的 <code>Redis</code> 节点上。</p>
<h1 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h1><p>由于 <code>RedisCluster</code> 采用 <strong>哈希分区规则</strong>，这里重点讨论 <strong>哈希分区</strong>。常见的 <strong>哈希分区</strong> 规则有几种，下面分别介绍：</p>
<h2 id="普通hash算法"><a href="#普通hash算法" class="headerlink" title="普通hash算法"></a>普通hash算法</h2><p>使用特定的数据，如 <code>Redis</code> 的 <strong>键</strong> 或 <strong>用户</strong> <code>ID</code>，再根据 <strong>节点数量</strong> <code>N</code> 使用公式： <code>hash（key）%N</code> 计算出 <strong>哈希值</strong>，用来决定数据 <strong>映射</strong> 到哪一个节点上。</p>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>这种方式的突出优点是 <strong>简单性</strong>，常用于 <strong>数据库</strong> 的 <strong>分库分表规则</strong>。一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong>中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>收尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p>
<ul>
<li><strong>优点</strong></li>
</ul>
<p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong>将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p>
<h2 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a>hash slot算法</h2><p><strong>虚拟槽分区</strong> 巧妙地使用了 <strong>哈希空间</strong>，使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（ <code>slot</code>）。这个范围一般 <strong>远远大于</strong> 节点数，比如 <code>RedisCluster</code> 槽范围是 <code>0~16383</code>。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>，如图所示：</p>
<p><img src="/img/redis2.jpg" alt=""></p>
<p>当前集群有 <code>5</code> 个节点，每个节点平均大约负责 <code>3276</code> 个 <strong>槽</strong>。由于采用 <strong>高质量</strong> 的 <strong>哈希算法</strong>，每个槽所映射的数据通常比较 <strong>均匀</strong>，将数据平均划分到 <code>5</code> 个节点进行 <strong>数据分区</strong>。 <code>RedisCluster</code> 就是采用 <strong>虚拟槽分区</strong>。</p>
<ul>
<li><strong>节点1</strong>： 包含 <code>0</code> 到 <code>3276</code> 号哈希槽。</li>
<li><strong>节点2</strong>：包含 <code>3277</code> 到 <code>6553</code> 号哈希槽。</li>
<li><strong>节点3</strong>：包含 <code>6554</code> 到 <code>9830</code> 号哈希槽。</li>
<li><strong>节点4</strong>：包含 <code>9831</code> 到 <code>13107</code> 号哈希槽。</li>
<li><strong>节点5</strong>：包含 <code>13108</code> 到 <code>16383</code> 号哈希槽。</li>
</ul>
<p>这种结构很容易 <strong>添加</strong> 或者 <strong>删除</strong> 节点。如果 <strong>增加</strong> 一个节点 <code>6</code>，就需要从节点 <code>1~5</code> 获得部分 <strong>槽</strong> 分配到节点 <code>6</code> 上。如果想 <strong>移除</strong> 节点 <code>1</code>，需要将节点 <code>1</code> 中的 <strong>槽</strong>移到节点 <code>2~5</code> 上，然后将 <strong>没有任何槽</strong> 的节点 <code>1</code> 从集群中 <strong>移除</strong> 即可。</p>
<p>由于从一个节点将 <strong>哈希槽</strong> 移动到另一个节点并不会 <strong>停止服务</strong>，所以无论 <strong>添加删除</strong> 或者 <strong>改变</strong> 某个节点的 <strong>哈希槽的数量</strong> 都不会造成 <strong>集群不可用</strong> 的状态.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/redis哨兵模式简单介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/redis哨兵模式简单介绍/" class="post-title-link" itemprop="url">redis哨兵模式简单介绍</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-11 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-11T17:01:21+08:00">2019-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:19:20" itemprop="dateModified" datetime="2019-03-02T15:19:20+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Redis</code> 的 <strong>主从复制</strong> 模式下，一旦 <strong>主节点</strong> 由于故障不能提供服务，需要手动将 <strong>从节点</strong> 晋升为 <strong>主节点</strong>，同时还要通知 <strong>客户端</strong> 更新 <strong>主节点地址</strong>，这种故障处理方式从一定程度上是无法接受的。 <code>Redis2.8</code> 以后提供了 <code>RedisSentinel</code> <strong>哨兵机制</strong>来解决这个问题。</p>
<h1 id="Redis高可用概述"><a href="#Redis高可用概述" class="headerlink" title="Redis高可用概述"></a>Redis高可用概述</h1><p>在 <code>Redis</code> 中，实现 <strong>高可用</strong> 的技术主要包括 <strong>持久化</strong>、<strong>复制</strong>、<strong>哨兵</strong> 和 <strong>集群</strong>，下面简单说明它们的作用，以及解决了什么样的问题：</p>
<ul>
<li><strong>持久化</strong>：持久化是 <strong>最简单的</strong> 高可用方法。它的主要作用是 <strong>数据备份</strong>，即将数据存储在 <strong>硬盘</strong>，保证数据不会因进程退出而丢失。</li>
<li><strong>复制</strong>：复制是高可用 <code>Redis</code> 的基础，<strong>哨兵</strong> 和 <strong>集群</strong> 都是在 <strong>复制基础</strong> 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。</li>
<li><strong>哨兵</strong>：在复制的基础上，哨兵实现了 <strong>自动化</strong> 的 <strong>故障恢复</strong>。缺陷是 <strong>写操作</strong> 无法 <strong>负载均衡</strong>，<strong>存储能力</strong> 受到 <strong>单机</strong> 的限制。</li>
<li><strong>集群</strong>：通过集群， <code>Redis</code> 解决了 <strong>写操作</strong> 无法 <strong>负载均衡</strong> 以及 <strong>存储能力</strong> 受到 <strong>单机限制</strong> 的问题，实现了较为 <strong>完善</strong> 的 <strong>高可用方案</strong>。</li>
</ul>
<h1 id="Redis哨兵的基本概念"><a href="#Redis哨兵的基本概念" class="headerlink" title="Redis哨兵的基本概念"></a>Redis哨兵的基本概念</h1><p><code>RedisSentinel</code> 是 <code>Redis</code> <strong>高可用</strong> 的实现方案。 <code>Sentinel</code> 是一个管理多个 <code>Redis</code> 实例的工具，它可以实现对 <code>Redis</code> 的 <strong>监控</strong>、<strong>通知</strong>、<strong>自动故障转移</strong>。下面先对 <code>RedisSentinel</code> 的 <strong>基本概念</strong> 进行简单的介绍。</p>
<p>如图所示， <code>Redis</code> 的 <strong>主从复制模式</strong> 和 <code>Sentinel</code> <strong>高可用架构</strong> 的示意图：</p>
<p><img src="/img/redis1.jpg" alt=""></p>
<h1 id="Redis主从复制的问题"><a href="#Redis主从复制的问题" class="headerlink" title="Redis主从复制的问题"></a>Redis主从复制的问题</h1><p><code>Redis</code> <strong>主从复制</strong> 可将 <strong>主节点</strong> 数据同步给 <strong>从节点</strong>，从节点此时有两个作用：</p>
<ol>
<li>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 作为 <strong>主节点</strong> 的 <strong>备份</strong> 可以随时顶上来。</li>
<li>扩展 <strong>主节点</strong> 的 <strong>读能力</strong>，分担主节点读压力。</li>
</ol>
<p><strong>主从复制</strong> 同时存在以下几个问题：</p>
<ul>
<li>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 晋升成 <strong>主节点</strong>，同时需要修改 <strong>应用方</strong> 的 <strong>主节点地址</strong>，还需要命令所有 <strong>从节点</strong> 去 <strong>复制</strong> 新的主节点，整个过程需要 <strong>人工干预</strong>。</li>
<li><strong>主节点</strong> 的 <strong>写能力</strong> 受到 <strong>单机的限制</strong>。</li>
<li><strong>主节点</strong> 的 <strong>存储能力</strong> 受到 <strong>单机的限制</strong>。</li>
<li><strong>原生复制</strong> 的弊端在早期的版本中也会比较突出，比如： <code>Redis</code> <strong>复制中断</strong>后，<strong>从节点</strong> 会发起 <code>psync</code>。此时如果 <strong>同步不成功</strong>，则会进行 <strong>全量同步</strong>，<strong>主库</strong> 执行 <strong>全量备份</strong> 的同时，可能会造成毫秒或秒级的 <strong>卡顿</strong>。</li>
</ul>
<h1 id="Redis-Sentinel深入探究"><a href="#Redis-Sentinel深入探究" class="headerlink" title="Redis Sentinel深入探究"></a>Redis Sentinel深入探究</h1><h2 id="Redis-Sentinel的主要功能"><a href="#Redis-Sentinel的主要功能" class="headerlink" title="Redis Sentinel的主要功能"></a>Redis Sentinel的主要功能</h2><p><code>Sentinel</code> 的主要功能包括 <strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移</strong>（ <code>failover</code>）、<strong>主从切换</strong>。 <code>Redis</code> 的 <code>Sentinel</code> 最小配置是 <strong>一主一从</strong>。</p>
<p><code>Redis</code> 的 <code>Sentinel</code> 系统可以用来管理多个 <code>Redis</code> 服务器，该系统可以执行以下四个任务：</p>
<ul>
<li><strong>监控</strong></li>
</ul>
<p><code>Sentinel</code> 会不断的检查 <strong>主服务器</strong> 和 <strong>从服务器</strong> 是否正常运行。</p>
<ul>
<li><strong>通知</strong></li>
</ul>
<p>当被监控的某个 <code>Redis</code> 服务器出现问题， <code>Sentinel</code> 通过 <code>API</code> <strong>脚本</strong> 向 <strong>管理员</strong> 或者其他的 <strong>应用程序</strong> 发送通知。</p>
<ul>
<li><strong>自动故障转移</strong></li>
</ul>
<p>当 <strong>主节点</strong> 不能正常工作时， <code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong>指向 <strong>新的主节点</strong>。</p>
<ul>
<li><strong>配置提供者</strong></li>
</ul>
<p>在 <code>RedisSentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</p>
<h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<ul>
<li><strong>主观下线</strong></li>
</ul>
<p><strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code>毫秒内， <code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</p>
<ul>
<li><strong>客观下线</strong></li>
</ul>
<p><strong>客观下线</strong> 只适用于 <strong>主节点</strong>。如果 <strong>主节点</strong> 出现故障， <code>Sentinel</code> 节点会通过 <code>sentinelis-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 <strong>主节点</strong> 不可达，则该 <code>Sentinel</code> 节点会判断 <strong>主节点</strong> 为 <strong>客观下线</strong>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/10/redis简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/10/redis简介/" class="post-title-link" itemprop="url">redis简介</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-10 17:01:21" itemprop="dateCreated datePublished" datetime="2019-02-10T17:01:21+08:00">2019-02-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 11:47:16" itemprop="dateModified" datetime="2019-03-02T11:47:16+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Redis</code> 是一种基于 <strong>键值对</strong> 的 <code>NoSQL</code> 数据库。</p>
<h1 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h1><ol>
<li>速度快，最快可达到 <code>10wQPS</code>（基于 <strong>内存</strong>， <code>C</code> 语言，<strong>单线程</strong> 架构）；</li>
<li>基于 <strong>键值对</strong> ( <code>key/value</code>) 的数据结构服务器。全称 <code>RemoteDictionaryServer</code>。包括 <code>string</code>(<strong>字符串</strong>)、 <code>hash</code>(<strong>哈希</strong>)、 <code>list</code>(<strong>列表</strong>)、 <code>set</code>(<strong>集合</strong>)、 <code>zset</code>(<strong>有序集合</strong>)、 <code>bitmap</code>(<strong>位图</strong>)。同时在 <strong>字符串</strong> 的基础上演变出 <strong>位图</strong>（ <code>BitMaps</code>）和 <code>HyperLogLog</code> 两种数据结构。 <code>3.2</code> 版本中加入 <code>GEO</code>（<strong>地理信息位置</strong>）。</li>
<li>丰富的功能。例如：<strong>键过期</strong>（缓存），<strong>发布订阅</strong>（消息队列）， <code>Lua</code> 脚本（自己实现 <code>Redis</code> 命令），<strong>事务</strong>，<strong>流水线</strong>（ <code>Pipeline</code>，用于减少网络开销）。</li>
<li>简单稳定。无外部库依赖，单线程模型。</li>
<li>客户端语言多。</li>
<li><strong>持久化</strong>（支持两种 <strong>持久化</strong> 方式 <code>RDB</code> 和 <code>AOF</code>）。</li>
<li><strong>主从复制</strong>（分布式的基础）。</li>
<li><strong>高可用</strong>（ <code>RedisSentinel</code>），<strong>分布式</strong>（ <code>RedisCluster</code>）和 <strong>水平扩容</strong>。</li>
</ol>
<h1 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>合理的使用 <strong>缓存</strong> 能够明显加快访问的速度，同时降低数据源的压力。这也是 <code>Redis</code> 最常用的功能。 <code>Redis</code> 提供了 <strong>键值过期时间</strong>（ <code>EXPIRE key seconds</code>）设置，并且也提供了灵活控制 <strong>最大内存</strong> 和 <strong>内存溢出</strong> 后的 <strong>淘汰策略</strong>。</p>
<h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>每个网站都有自己的排行榜，例如按照 <strong>热度排名</strong> 的排行榜，<strong>发布时间</strong> 的排行榜，<strong>答题排行榜</strong> 等等。 <code>Redis</code> 提供了 <strong>列表</strong>（ <code>list</code>）和 <strong>有序集合</strong>（ <code>zset</code>）数据结构，合理的使用这些数据结构，可以很方便的构建各种排行榜系统。</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p><strong>计数器</strong> 在网站应用中非常重要。例如：<strong>点赞数</strong>加 <code>1</code>，<strong>浏览数</strong> 加 <code>1</code>。还有常用的 <strong>限流操作</strong>，限制每个用户每秒 <strong>访问系统的次数</strong> 等等。 <code>Redis</code> 支持 <strong>计数功能</strong>（ <code>INCR key</code>），而且计数的 <strong>性能</strong> 也非常好，计数的同时也可以设置 <strong>超时时间</strong>，这样就可以 <strong>实现限流</strong>。</p>
<h2 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h2><p>赞/踩，粉丝，共同好友/喜好，推送，下拉刷新等是社交网站必备的功能。由于社交网站 <strong>访问量通常比较大</strong>，而且 <strong>传统的数据库</strong> 不太适合保存这类数据， <code>Redis</code>提供的 <strong>数据结构</strong> 可以相对比较容易实现这些功能。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><code>Redis</code> 提供的 <strong>发布订阅</strong>（ <code>PUB/SUB</code>）和 <strong>阻塞队列</strong> 的功能，虽然和专业的消息队列比，还 <strong>不够强大</strong>，但对于一般的消息队列功能基本满足。</p>
<h1 id="Redis安装与配置"><a href="#Redis安装与配置" class="headerlink" title="Redis安装与配置"></a>Redis安装与配置</h1><p>这里就不展示redis的安装与配置了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/Java实现二叉树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/25/Java实现二叉树/" class="post-title-link" itemprop="url">java实现二叉树</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-25 17:01:21" itemprop="dateCreated datePublished" datetime="2019-01-25T17:01:21+08:00">2019-01-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:56:22" itemprop="dateModified" datetime="2019-03-02T15:56:22+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java数据结构/" itemprop="url" rel="index"><span itemprop="name">java数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBiTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> data;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node(<span class="keyword">char</span> data)&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="前中序列构建二叉树"><a href="#前中序列构建二叉树" class="headerlink" title="前中序列构建二叉树"></a>前中序列构建二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 根据 前 中 序列 构建二叉树</span><br><span class="line">    public Node build(String preOrder,String inOrder)&#123;</span><br><span class="line">        if(preOrder.isEmpty())</span><br><span class="line">            return null;</span><br><span class="line">        char rootValue = preOrder.charAt(0);</span><br><span class="line">        int rootIndex = inOrder.indexOf(rootValue);</span><br><span class="line"></span><br><span class="line">        Node root = new Node(rootValue);</span><br><span class="line">        root.left = build(</span><br><span class="line">                preOrder.substring(1,1+rootIndex),</span><br><span class="line">                inOrder.substring(0,rootIndex)</span><br><span class="line">        );</span><br><span class="line">        root.right = build(</span><br><span class="line">              preOrder.substring(1+rootIndex),</span><br><span class="line">              inOrder.substring(1+rootIndex)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归前序遍历"><a href="#递归前序遍历" class="headerlink" title="递归前序遍历"></a>递归前序遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder(Node root)&#123;</span><br><span class="line">        if(root != null)&#123;</span><br><span class="line">            System.out.print(root.data+&quot; &quot;);</span><br><span class="line">            preOrder(root.left);</span><br><span class="line">            preOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归后续遍历"><a href="#递归后续遍历" class="headerlink" title="递归后续遍历"></a>递归后续遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void afterOrder(Node root)&#123;</span><br><span class="line">        if(root != null)&#123;</span><br><span class="line">            afterOrder(root.left);</span><br><span class="line">            afterOrder(root.right);</span><br><span class="line">            System.out.print(root.data+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/java实现循环队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/23/java实现循环队列/" class="post-title-link" itemprop="url">java实现循环队列</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-23 17:01:21" itemprop="dateCreated datePublished" datetime="2019-01-23T17:01:21+08:00">2019-01-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:56:29" itemprop="dateModified" datetime="2019-03-02T15:56:29+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java数据结构/" itemprop="url" rel="index"><span itemprop="name">java数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里给出用数组实现的循环队列。采用牺牲一个单元格的方式判断队列满</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头 删</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾 插</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队 从rear入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断队列是否已满  采用牺牲单元格的做法</span></span><br><span class="line">        <span class="keyword">if</span>((rear+<span class="number">1</span>)%max == front)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列满"</span>);</span><br><span class="line">        data[rear] = value;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 出队</span><br><span class="line">    public int deQueue()&#123;</span><br><span class="line">        // 队列为空 不能出队</span><br><span class="line">        if(front == rear)</span><br><span class="line">            throw new RuntimeException(&quot;队列空&quot;);</span><br><span class="line">        int value = data[front];</span><br><span class="line">        front = (front+1)%max;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/java实现栈/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sbing">
      <meta itemprop="description" content="你只管努力，剩下的交给天意">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sbing的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/22/java实现栈/" class="post-title-link" itemprop="url">java实现栈</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-22 17:01:21" itemprop="dateCreated datePublished" datetime="2019-01-22T17:01:21+08:00">2019-01-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-02 15:56:35" itemprop="dateModified" datetime="2019-03-02T15:56:35+08:00">2019-03-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java数据结构/" itemprop="url" rel="index"><span itemprop="name">java数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java实现栈、用数组实现。主要还是给出常规的操作</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;<span class="comment">//栈的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        top = -<span class="number">1</span>; <span class="comment">// 初始化为 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 栈不满 就可以入栈</span></span><br><span class="line">        <span class="keyword">if</span>(top == max-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈已满"</span>);</span><br><span class="line">        data[++top] = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 出栈</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if(top == -1)</span><br><span class="line">            throw new RuntimeException(&quot;栈为空&quot;);</span><br><span class="line">        return data[top--];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sbing</p>
              <p class="site-description motion-element" itemprop="description">你只管努力，剩下的交给天意</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sbing</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
